\section{Numerische Lineare Algebra, Lineare Gleichungssysteme}
\textbf{ZIEL}: Beantwortung folgender Fragen:
\begin{itemize}
\item{Gibt es Algorithmen, so dass große Abweichungen der berechneten Lösung (Lsg) zur tatsöchlichen nicht auftreten? 
  (``Es kommt darauf an'')}
\item{Kann man vorhersagen wann es zu großen Fehlern kommt, und wann nicht? (Ja)}
\end{itemize}

\begin{equation*}
  \left.
    \begin{aligned}
      \exists \widetilde{x} \neq 0: A\widetilde{x} = 0 & \Rightarrow  Ax = b \\
        & \Rightarrow A(x + \alpha \widetilde{x}) = b
%      \exists \widetilde{x} \neq 0: A\widetilde{x} = 0 \Rightarrow & Ax = b  \\
%      & A(x + \alpha \widetilde{x}) = b
%		\Fhat = \F \cup \F_d \hspace{0.5cm} \text{mit} \hspace{0.5cm} & \F && \text{normalisierte Gleitpunktzahlen}\\
%		 &\F_d && \text{denormalisierte Gleitpunktzahlen} 
    \end{aligned}
  \right\}
  \text{linear aber nicht eindeutig} %TODO christof: ich hab lösbar, aber nicht eindeutig stehen
\end{equation*}

\subsection{Grundlegendes}

\subsubsection{Matrix Norm}

Jede Norm über $\mathbb{K}^{m \times n}$ heißt Matrixnorm.
Matrixnormen lassen sich durch Vektornormen induzieren:
\begin{equation*}
\|A\|_p \coloneqq \underset{x \neq 0}{max} \frac{\|Ax\|_p}{\|x\|_p} = \underset{\|x\|_p = 1}{max}\|Ax\|_p
\end{equation*}

z.B.: $p \in \left\{1, 2, \infty \right\}$

Für induzierte Normen gilt:

\begin{itemize}
\item{$\|Ax\|_p \leq \|A\|_p \|x\|_p$}
\item{$\|A B\|_p \leq \|A\|_p \|B\|_p$}
\end{itemize}
Lässt sich einfach beweisen.

Im folgenden werden nur induzierte Normen verwendet.

\textbf{Satz:}
Sei $A \in \mathbb{K}^{m \times n}$. Dann gilt:
\begin{enumerate}[a)]
  \item{$\|A\|_1 = \underset{j = 1,..,n}{max} \sum\limits_{i=1}^{m}{\left|a_{ij}\right|}$ ( Spaltensummennorm )}
  \item{$\|A\|_{\infty} = \underset{j = 1,..,m}{max} \sum\limits_{i=1}^{n}{\left|a_{ij}\right|}$ ( Zeilensummennorm )}
  \item{$\|A\|_2 = \sqrt{\lambda_{max}\left(A^*A\right)}$}
\end{enumerate}
\textbf{Beweise:} a), b) durch einsetzen, c) benötigt Mittel aus linearen Algebra.

\subsubsection{$\left(Relative\right)$ Kondition einer Matrix}
Geg.: Sei $Ax = b$ (ungestörtes System), wobei
$A \in \mathbb{K}^{m \ times n}$ invertierbar und $b \in \mathbb{K}^n$ sei.  \\
Wie wirken sich Störungen $\Delta A$ und $\Delta b$ aus:  \\
\begin{align*}
  \left(A+\Delta A\right) \left(x+\Delta x\right)=b+\Delta b  \tag{gestörtes System}\\
  ? \quad \frac{\norm{\Delta x}}{\norm{x}} 
\end{align*}

Zunächst: Nur Störung von $b$ durch $\Delta b$, d.h. $A(x + \Delta x) = b + \Delta b$\\
$\Delta x = ?$
\begin{align*}
  A (x + \Delta x) &= b + \Delta b\\
  A \Delta x &= \Delta b\\
  \Delta x &= A^{-1} \Delta b\\
  \norm{\Delta x} &= \norm{ A^{-1} \Delta b } \leq \norm{A^{-1}} \norm{\Delta b}\\
  \norm{b} &= \norm{Ax} \leq \norm{A}\norm{b} \Rightarrow \frac{1}{\norm{x}} \leq \frac{\norm{A}}{\norm{b}} \\
  \Rightarrow \frac{\norm{\Delta x}}{\norm{x}} &\leq \norm{A}\norm{A^{-1}}\frac{\norm{\Delta b}}{\norm{b}} 
\end{align*}
\definition Sei $A$ invertierbar. $\kappa(A) := \norm{A}\norm{A^{-1}}$ heißt Konditionszahl von $A$ bzgl. $\norm{.}$.\\
\satz Sei $A$ invertierbar und $\Delta A$ sowie $\Delta b$ Störungen von $Ax=b$.
Dann gilt für hinreichend kleine $\Delta A$
\begin{align*}
  (A+\Delta A)(x + \Delta x) &= b + \Delta b\\
  \text{mit } \frac{\norm{\Delta x}}{\norm{x}} &\leq \frac{\kappa(A)}{1-\kappa(A)\frac{\norm{\Delta A}}{\norm{A}} } \left( \frac{\norm{\Delta A}}{\norm{A}} + \frac{\norm{\Delta b}}{\norm{b}} \right)
\end{align*}

TODO Fehlendes nachtragen
...

Berechnung von $\kappa_2\left(A\right)$
\begin{equation*}
  \begin{aligned}
    \kappa_2(A) = \|A\|_2 \|A^{-1}\|_2 = &\sqrt{\lambda_{max}\left(A^*A\right)} \cdot \frac{1}{\sqrt{\lambda_{min}\left(A^*A\right)}} \\
    = &\frac{\sigma_1\left(A\right)}{\sigma_n\left(A\right)}
  \end{aligned}
\end{equation*}
Für symmetrische und positiv definite $\frac{\sigma_1\left(A\right)}{\sigma_n\left(A\right)}$ Matrizen:
\begin{equation*}
  \kappa_2(A) = \frac{\lambda_{max}\left(A\right)}{\lambda_{min}\left(A\right)}
\end{equation*}

Bemerkung: Man beachte, dass in diesem Abschnitt die Konditionszahl einer Matrix $A$ definiert wurde und nicht die des Problems:
$Input\left(A,B\right) \rightarrow Output\left(A^{-1}b\right)$
Letzteres kann über den Ansatz in Abschnitt  berechnet werden und hängt eng mit $\kappa_A$ zusammen.

\textbf{Zeilenskalierung}
Bsp.: NUR DEMO!
\begin{equation*}
  \begin{aligned}
    \hspace{1cm} &Ax = \begin{pmatrix} 10^8 & 0 \\ 0 & 10^{-8} \end{pmatrix} x = \begin{pmatrix}b_1 \\ b_2\end{pmatrix} \\
    &\kappa_\infty\left(A\right) = 10^8 \cdot 10^8 = 10^{16}
  \end{aligned}
\end{equation*}
Vorkonditionierung durch Diagonalmatrix
\begin{equation*}
  D = \begin{pmatrix}10^{-8} & 0 \\ 0 & 10^8\end{pmatrix},
\end{equation*}
d.h. Löse statt Ax = b, dass dazu äquivalente System
\begin{equation*}
  \begin{aligned}
    &DAx = Db \\
    &\kappa_\infty\left(DA\right) = \kappa_\infty\left(I\right) = 1
	\end{aligned}	
\end{equation*}

Verbesserung der Konditionszahl bezgl. $\|.\|_\infty$ durch Zeilenskalierung.
Definiere: Diagonalmatrix:
\begin{equation*}
  D_z \left[ i,i \right] \coloneqq \left(\sum\limits_{j=1}^{n}{\left|a_{ij}\right|}\right)^{-1} %
\end{equation*}
Dann gilt:
\begin{equation*}
  \begin{aligned}
    &\sum\limits_{j=1}^{n}{\left|D_zA\left[i,j\right]\right|} = 1  \hspace{2cm} \text{für } 1, \ldots, n \\
    &\Rightarrow \|D_zA\|_\infty = 1
		\end{aligned}
\end{equation*}

\textbf{Satz:}
$\kappa_\infty\left(D_zA\right) \leq \kappa_\infty\left(DA\right)$ \hspace{2cm} $\forall$ regulären Diagonalmatrizen

\textbf{Beweis:}
Sei $A$ bereits äquilibriert, d.h.:
\begin{align*}
    &\sum\limits_{j=1}^{n}{\left|A\left[i,j\right]\right|} = 1 \hspace{2cm} \text{für } i = 1, \dots, n \\
	  &\Rightarrow \|A\|_\infty = 1 \\
	  &\Rightarrow \kappa_\infty\left(A\right) = \|A\|_\infty \|A^{-1}\|_\infty = \|A^{-1}\|_\infty
\end{align*}

Sei $D$ eine beliebige reguläre Diagonalmatrix
\begin{equation*}
\begin{aligned}
  \|DA\|_\infty = &\underset{1 \leq i \leq n}{max} \left\{\sum\limits_{j=1}^{n}{\left|d_ia_{ij}\right|}\right\} =
  \underset{1 \leq i \leq n}{max}\left\{\left|d_i\right|\sum\limits_{j=1}^{n}{\left|a_{ij}\right|}\right\} = \\
  &\underset{1 \leq i \leq n}{max}\left\{\left|d_i\right|\right\} = \|D\|_\infty = 
  \|\left(DA\right)^{-1}\|_\infty = \underset{x \neq 0}{max}\left\{\frac{\|A^{-1}D^{-1}x\|_\infty}{\|x\|_\infty}\right\} = \\
  &\underset{y \neq 0}{max}\left\{\frac{\|A^{-1}y\|_\infty}{\|Dy\|_\infty}\right\} \geq \underset{y \neq 0}{max}\left\{\frac{\|A^{-1}y\|_\infty}{\|D\|_\infty\|y\|_\infty}   \right\} \\
  &\Rightarrow \kappa_\infty\left(DA\right) = \|DA\|_\infty \|\left(DA\right)^{-1}\|_\infty \geq \\
  &\hcancel{$\|D\|_\infty$} \|A^{-1}\|_\infty \hcancel{$\|D\|_{\infty}^{-1}$} = \kappa_\infty\left(A\right)
\end{aligned}
\end{equation*}

\subsubsection{Residuum}
Sei $\widetilde
{x}$ eine Näherungslösung von GLS
\begin{equation*}
Ax=b
\end{equation*}
Dann bezeichnet man
\begin{equation*}
r \coloneqq r_{\widetilde{x}} \coloneqq A\widetilde{x} - b
\end{equation*}

als Residuum.
\textbf{ACHTUNG:}
\begin{itemize}
  \item{Residuum ist nicht der Fehler von $\widetilde{x}$}
	\item{Für die exakte Lösung $x$ gilt:}
\end{itemize}
\begin{equation*}
r_x = Ax - b = 0
\end{equation*}

Frage: Ist $r_{\widetilde{x}}$ ein guter Indikator dafür, wie genau $\widetilde{x}$ ist?
Antw.: Nein, außer Matrix ist gut Knoditioniert!

\textbf{Satz:}
Sei $a \in \mathbb{K}^{n \times n}$ invertierbar und $\widetilde{x}$ Näherungslösung von
\begin{equation*}
\begin{aligned}
Ax = b \hspace{2cm} b \neq 0
\end{aligned}
\end{equation*}
Dann gilt:
\begin{equation*}
\frac{\|x - \widetilde{x}\|}{\|x\|} \leq \kappa\left(A\right) \frac{\|r\|}{\|b\|}
\end{equation*}
\textbf{Beweis:}
\begin{equation*}
\begin{aligned}
r &= A\widetilde{x} - b = A\widetilde{x} - Ax = A\left(\widetilde{x} - x\right) \\
&\Rightarrow \widetilde{x} - x = A^{-1}r \\
&\|\widetilde{x} - x\| = \|A^{-1}r\| \leq \|A^{-1}\|\|r\| \\
&\|b\| = \|Ax\| \leq \|A\|\|x\| \\
&\frac{1}{\|x\|} \leq \frac{\|A\|}{\|b\|}
\end{aligned}
\end{equation*}

\subsection{Direkte Lösung von Linearen Gleichungssystemen (in n - Schritten exakte Lsg)}
\subsubsection{Gauß - Algorithmus und LR - Zerlegung}
Zunächst: Voraussetzung das Gauß - Algorithmus ohne Zeilen verauschen druchführbar sei:

\begin{equation*}
  \begin{aligned}
    Ax = b \\
    &a_{11}^{\left(1\right)}x_1 + \ldots + a_{1n}^{\left(1\right)}x_n = b_1^{\left(1\right)}  \\
    &\vdots                               \vdots                     = \vdots  \\
    &a_{n1}^{(1)}x_1 + \ldots + a_{nn}^{(1)}x_n = b_n^{(1)}  \\
  \end{aligned}
\end{equation*}

1.Schritt: Subtrahiere das $\left(\frac{a_{i1}}{a_{11}}\right) =: L_{i1}$ - fache der 1. Zeile
von der i-ten Zeile, i = 2, ..., n.
\begin{align*}
    a_{11}^{(1)}x_1 + \ldots + a_{1n}^{(1)}x_n = b_1^{(1)}  \\
		\vdots                    +a_{22}^{(2)}x_2 \ldots + a_{1n}^{(2)}x_n = b_2^{(2)}  \\
    \vdots                               \vdots                     = \vdots  \\
    \ldots  + a_{2n}^{(2)}x_2 + a_{nn}^{(2)}x_n = b_n^{(2)} \\
\end{align*}
\begin{align*}
    A^{(2)} = L_1A^{(1)}, \text{wobei dieses bleibt gleich} \\
\end{align*}
\begin{align*}
    L_1 = \begin{pmatrix} 1 & \ldots &        &  \\ 
		                -L_{21} & 1      & 0      &  \\
					          \vdots	& 0      & \ddots &  \\
										-L_{n1} & \ldots &        & 1
					\end{pmatrix}
\end{align*}
\begin{align*}
		s. Schritt: A^{\left(s\right)} = L_{s-1}A^{\left(s-1\right)} \\
\end{align*}
\begin{align*}
		A_s = \begin{pmatrix}
		      a_{11}^{\left(1\right)} & a_{12}^{\left(1\right)} & \ldots & \ldots & a_{1n}^{\left(1\right)} \\
					\vdots                  & a_{22}^{\left(2\right)} & \ldots & \ldots & a_{2n}^{\left(2\right)} \\
					\vdots                  & \ddots                  & \ldots & \ldots & \vdots                  \\
					                        &                         & a_{ss}^{\left(s\right)} & \ldots  & a_{sn}^{\left(s\right)} \\
																	&                         & a_{ns}^{\left(s\right)} & \ldots  & a_{nn}^{\left(s\right)}
		      \end{pmatrix}
					b = \begin{pmatrix}b_1^{\left(1\right)} \\ b_2^{\left(2\right)} \\ \vdots \\ b_s^{\left(s\right)} \\ b_n^{\left(s\right)}\end{pmatrix}\\
\end{align*}
\begin{align*}
		L_s = \begin{pmatrix}
		      1 &   &        &            &        &        & \\
					  & 1 &        &            &        &        & \\
						&   & \ddots &            &        &        & \\
						&   &        & 1          &        &        & \\
						&   &        & -L_{s+1,s} & \ddots &        & \\
						&   &        & \vdots     &        & \ddots & \\
						&   &        & -L_{ns}    &        &        & 1
		      \end{pmatrix}
\end{align*}
\begin{align*}
  L_{i,s} = \frac{a_{i,s}^{(s)}}{a_{s,s}^{(s)}} \text{für } i = s + 1, \ldots, n
\end{align*}

Schritt n-1: $A^{\left(n\right)} = L_{n-1}A^{n-1}$
Rechte obere
$\Delta$-Matrix

D.h.: 
\begin{equation*}
  \begin{aligned}
A = A^{(1)} \rightarrow A^{(2)} = L_1A^{(1)} \rightarrow A^{(3)} = L_2A^{(2)} \ldots \rightarrow A^{(n)} = L_{n-1}A^{(n-1)} \\
A^{(3)} = L_2L_1A^{(1)}
  \end{aligned}
\end{equation*}
bzw.
\begin{equation*}
  \begin{aligned}
    R = A^{(n)} = L_{n-1} \ldots L_1 A  \\
		(L_{n-1}, \ldots, L_1)^{-1}R = A  \\
		\underbrace{(L_1^{-1} \cdot \ldots \cdot L_{n-1}^{-1})}{=:L}R = A  \\
%		=: L  und  \\
		L = \begin{pmatrix}
		    1      &        &        &  \\
				L_{21} & \ddots & 0      &  \\
				\vdots &        & \ddots &  \\
				L_{n1} & \ldots & L_{n\left(n-1\right)} & 1
		    \end{pmatrix}
	\end{aligned}
\end{equation*}

\textbf{Beweis:}
Lässt sich über nachrechnen leicht überprüfen

\textbf{LR = A} % Todo: sollte in einer Box sein!
Algorithmus (Gauß a. - ohne Zeilen vertauschen)
\begin{equation*}
  for s = 1, .., n-1  \\
	  for i = s+1, ..., n  \\
		  L_{is} = \frac{a_{is}}{a_{ss}^{\left(s\right)}}  \\
			b_i^{\left(s+1\right)} = b_i{\left(s\right)} - L_{is}b_s^{\left(s\right)}
			[a_{i, s+1}^{(s+1)} \ldots a_{i,n}^{(s+1)}] = [a_{i, s+1}^{(s)} \ldots a_{i,n}^{(s)}] - L_{i,s}[a_{s,s+1}^{(s)} \ldots a_{s,n}^{(s)}]
		end
	end
\end{equation*}
%
\textbf{Satz:}
Für den Gauß - Algorithmus sind $\frac{2}{3}n^3 + \mathcal O(n^2)$ Arithmetische Operationen erforderlich.

\textbf{Beweis:}
Schritt s: (s = 1, .., n-1)
\begin{equation*}
  \begin{aligned}
	  : n-s [s+1, s+2, \ldots, s+n - s] \\
		\cdot n-s + (n-s)(n-s) = n^2 - 2ns +s^2 \\
		- n-s + (n-s)(n-s) \\
		\hline
		\underbrace{2 \cdot \sum\limits_{s=1}^{n-1}{s^2}}{2 \frac{(n-1)n(2n-1)}{6}}+\underbrace{\sum\limits_{s=1}^{n-1}{s}}_{3\frac{(n-1)n}{2}}
	\end{aligned}
\end{equation*}

TODO nachschauen ob sicher nichts fehlt\\

Zeitaufwand für Gauß-Verfahren Intel Core i7, 3GHz $\approx 100$GFlops:\\
\begin{tabular}{c | r l}
  $n = 10^4$ & $6,6$ &s\\
  $n = 10^5$ & $1,85$ &h\\
  $n = 10^6$ & $77$ &Tage
\end{tabular}\\
Gauß-Verfahren mit Zeilenvertauschung (Spaltenpivotisierung)\\
Zu Beginn des Schrittes s sucht man das größte Element von $[a_{ss}^{(s)}\ldots a_{ns}^{(s)}]^T$
und vertausche Zeile s mit derjenigen Zeile, die das größte Element des obigen Vektors hat.
Dies ist notwendig:
\begin{itemize}
  \item damit GV i.A. durchführbar ist,
  \item wegen numerischer Stabilität (siehe später)
\end{itemize}
\satz Sei $A \in \mathbb{K}^{n \times n}$ regulär, dann existiert eine Permutationsmatrix $P$,
so dass $PA = LR$ ist, wobie $L$ linke und $R$ rechte Dreiecksmatrix ist.\\
\beweis Findet man in jedem Numerik-Lehrbuch\\
\matlab{lu(A)}\\

Die Lösung $Ax=b$ mittels LR-Zerlegung:\\
$Ax = b \Leftrightarrow PAx = Pb \Leftrightarrow L\underbrace{Rx}_{y} = Pb \Leftrightarrow [Ly = Pb \text{ und } Rx = y]$
\begin{enumerate}
  \item LR-Zerlegung von A: Aufwand $\frac{2}{3} n^3 + \LandauO(n^2)$
  \item Löse $Ly = Pb$ (``Vorwärtseinsetzen''): $n^2$
  \item Löse $Rx = y$ (``Rückwärtseinsetzen''): $n^2$
\end{enumerate}
Gesamtaufwand: $\frac{2}{3} n^3 + \frac{3}{2} n^2 + \LandauO(n) \qquad (A \in \mathbb{R}^{n \times n})$\\
Anteil von Vorwärst- und Rückwärtseinsetzen an den Gesamtkosten $\approx \frac{3}{n}$.\\
Bei $n=100 \quad 3\%$; bei $n=1000 \quad 0,3\%$

Bsp: GV ohne Spaltenpivotisierung
\begin{align*}
  A = \begin{pmatrix}
    10^{-20} & 1\\
    1        & 1
  \end{pmatrix}
  ,\quad b = \begin{pmatrix} 3 \\ 3 \end{pmatrix}
\end{align*}
$Ax = b$ Matrix $A$ ist gut konditioniert: $\kappa_2(A) = 2,6$\\
$\Rightarrow x = \begin{pmatrix} 0 \\ 3 \end{pmatrix}$ [``cond(A,2)'', Eigenvalue $A^* A$ (größerer)]\\
GV mit $eps = 10^{-16}$\\
$rd(1-10^{20}) = -10^{20}$
\begin{align*}
  \hat{R} = \begin{pmatrix}
    10^{-20} & 1 \\
    0 & -10^{20}
  \end{pmatrix} && \hat{L} = \begin{pmatrix}
    1 & 0 \\
    10^{20} & 1
  \end{pmatrix}\\
  \hat{L} y = b: & \begin{pmatrix} 1 & 0 \\ 10^{20} & 1 \end{pmatrix} \begin{pmatrix} y_1 \\ y_2 \end{pmatrix} =
  \begin{pmatrix} 3 \\ 3 \end{pmatrix} \Rightarrow \begin{pmatrix} y_1 \\ y_2 \end{pmatrix} = \begin{pmatrix}
    3 \\ \underbrace{3 - 3\cdot 10^{20}}_{-3 \cdot 10^{20}}
  \end{pmatrix}\\
  \hat{R} x = y: & \begin{pmatrix} 10^{-20} & 1 \\ 0 & -10^{20} \end{pmatrix} \begin{pmatrix} x_1 \\ x_2 \end{pmatrix} =
  \begin{pmatrix} 3 \\ -3 \cdot 10^{20} \end{pmatrix} \Rightarrow x_2 = 3\\
  10^{-20}x_1 + 3 = 3 \Rightarrow x_1 = 0\\
  \text{Aber: } & \hat{L}\hat{R} = \begin{pmatrix} 10^{-20} & 1 \\ 1 & 0 \end{pmatrix} \\
  & \hat{L}\hat{R} \begin{pmatrix} \hat{x}_1 \\ \hat{x}_2 \end{pmatrix} = \begin{pmatrix} 3 \\ 3 \end{pmatrix} \\
  & \Rightarrow \hat{x}_1 = \hat{x}_2 = 3
\end{align*}
\begin{align*}
  \frac{\norm{\hat{x}-x}_{\infty}}{\norm{x}_\infty} = 100\%
\end{align*}
% subsubsubsection
\para{Fehleranalyse des Gauß-Verfahrens}
Einfluss von Rundungsfehlern?\\

\satz Sei $A \in \mathbb{C}^{n \times n}$ regulär und $b \in \mathbb{C}^n$. Seien $\hat{L}$ und $\hat{R}$ die mittels GV
berechneten Faktoeren der LR-Zerlegung von $A$ und $\hat{x}$ die berechnete Lösung für $Ax = b$, wobei mit
Maschinengenauigkeit $eps$ gerechnete wurde. Dann gilt:
\begin{align*}
  \frac{\norm{\hat{x}-x}_\infty}{\norm{x}_\infty} \leq \kappa(A) 3n^2 eps \norm{\hat{R}} + \LandauO(eps^2) \tag{*}
\end{align*}
\beweis Siehe Demmel (1999), Abs. 2.4.\\
Diskussion von (*):
\begin{enumerate}
  \item Der relative Fehler von $\hat{x}$ ist meist viel kleiner als in (*), $n^2$ wird nur im worst case angenommen
  \item Was weiß man über $\norm{\hat{R}}$?
    \begin{enumerate}[i]
      \item $\norm{\hat{R}}$ kann sehr groß werden, z.B. $2^{n-1}$
      \item Matrizen für die $\norm{\hat{R}}$ groß ist, sind sehr ``unwahrscheinlich'', was
        \begin{itemize}
          \item Experimente mit Zufallsmatrizen
          \item Anwendungsbeispiele in der Praxis
        \end{itemize}
        gezeigt haben.
    \end{enumerate}
\end{enumerate}
% subsubsubsection
\para{LR-Zerlegung für Bandmatrizen}
\definition Die Matrix
\begin{align*}
  A = \begin{pmatrix}
    a_{1,1} & \cdots & a_{1,p+1} & 0         & \cdots & 0\\
    \vdots  & \ddots &           & a_{2,p+2} & & \\
    a_{q+1,1} &      & \ddots    &           & \ddots & \\
    0       & a_{q+2,2} &        & \ddots    & & a_{n-p,n} \\
    \vdots  & \ddots & \ddots    &           & \ddots & \vdots \\
    0       & \cdots & 0         & a_{n,n-q} & \cdots & a_{n,n} \\
  \end{pmatrix}
\end{align*}
beziechnet man als Bandmatrix mit oberer Bandbreite $p$ und unterer Bandbreite $q$.
\missingfigure{Bandmatrix}
\missingfigure{Spaltenpivotisierung und numerische Stabilität Handout}
\satz Sei $A \in \mathbb{R}^{n \times n}$ eine Bandmatrix mit oberer Bandbreite $p$
und unterer Bandbreite $q$. Die LR-Zerlegung sei ohne Zeilenvertauschung durchführbar.
Dann hat $L$ untere Bandbreite $q$ und $R$ obere Bandbreite $p$.\\
\beweis
\begin{itemize}
  \item Zur Bestimmung von $R$ werden die Elemente oberhabl der Bandbreite nicht geändert.
  \item $l_{ij}$ beschreibt den Faktor für die Zeilensubtraktion. Unterhalb der Bandbreite
    sind keine Zeilesubtraktionen erforderlich.
\end{itemize}
Aufwand (arithmetische Opertionen) der LR-Zerlegung von $A \in \rnxn$
\begin{enumerate}
  \item LR-Zerlegung: $\approx 2 n pq$
  \item Vorwärtseinsetzen: $\approx 2 nq$
  \item Rückwärtseinsetzen: $\approx 2 np$
\end{enumerate}
Gasmt: $2n (pq + q + p)$, d.h. $\LandauO(n)$ für $n \gg \max\{ p, q \}$\\
\satz Sei $A \in \rnxn$ eine Bandmatrix, wie im letzten Satz. Wird die LR-Zerlegung
mit Spaltenpivotisierung durchgeführt, dann hat $R$ eine max. obere Bandbreite von
$p + q$ und $L$ hat pro Spalte maximal $q$ Nichtnulleinträge.\\
\beweis Demmel (1999), Abschnitt 2.7.3
\para{Dünnbesetzte Matrizen}
Treten z.B. bei der FEM auf. \matlab{sparse} Matrixklasse
\begin{itemize}
  \item LR-Zerlegung von dünnbesetzten Matrizen $\Rightarrow$ i.A. zu vollbesetzten $L$, $R$
  \item Durch Umsortierung lässt sich eine dünnbesetzte Matrix auf Bandstruktur bringen
\end{itemize}
Algorithmen zur LR-Zerlegung dünnbesetzter Matrizen:
\begin{itemize}
  \item Super LU
  \item UMFPACK
  \item PARDISO
\end{itemize}
Regel: Nie die Inverse einer Matrix berechnen, wenn nicht unbedingt erforderlich (numerisch sehr instabil)\\
Wenn $Ax_k = b_k$ für $k = 1,\ldots,m$ zu lösen ist, dann berechne LR-Zerlegung von A und nicht $A^{-1}$.\\
\matlab{$A\backslash[b_1,\ldots,b_m]$}

\subsubsection{Cholesky-Zerlegung}
\definition Eine Matrix $A$ heißt symmetrisch / hermitesch positiv definit (s.p.d),
falls $A^* = A$ und $x^*Ax > 0\,\forall x \neq 0$.\\
Treten häufig auf, z.B.: FEM, Ausgleichsrechnung, Optimierung\\
\satz Sei $A$ s.p.d., dann gilt:
\begin{enumerate}[a]
  \item $a_{ii} > 0$
  \item alle Eigenwerte von $A$ sind positiv (hinreichende Bedingung)
  \item $\kappa_2(A) = \frac{\lambda_{max}(A)}{\lambda_{min}(A)}$
\end{enumerate}
\satz Sei $A \in \rnxn$ s.p.d., dann existiert eine untere (linke) Dreiecksmatrix $L$
mit $A = LL^*$ (Cholesky Zerlegung)\\
Algorithmus:\\
\begin{flalign*}
  & \texttt{for } k = 1:n\\
  & \quad l_{kk} = \left( a_{kk} - \sum^{k-1}_{j=1} \abs{l_{kj}}^2 \right)^{\frac{1}{2}}\\
  & \quad \texttt{for } i=k+1:n\\
  & \qquad l_{ik} = \frac{a_{ik} - \sum^{k-1}_{j=1} l_{ij} \bar{l}_{kj}}{l_{kk}} \\
  & \quad \texttt{end}\\
  & \texttt{end}
\end{flalign*}
\beweis Siehe Lehrbuch Numerik\\
Eigenschaften:\\
\begin{itemize}
  \item Aufwand $\frac{1}{3} n^3 + \LandauO(n^2)$ Flops für $A \in \rnxn$
  \item Numerisch stabil ($Ax=b$): $\frac{\norm{\hat{x}-x}_\infty}{\norm{x}_\infty} \leq \kappa_\infty(A) 3n^2 eps + \LandauO(eps)$
\end{itemize}
d.h. ist $A$ gut konditioniert, dann kann der Fehler nicht ``explodieren''.\\
Ist Matrix nicht s.p.d., dann kommt bei obigem Algorithmus NaN heraus.\\
\matlab{chol(A)}

\subsubsection{QR-Zerlegung}
\definition Eine Matrix $A \in \rmxn$ mit $m \geq n$ sei gegeben. Die Faktorisierung $A = QR$, TODO(Matrixformen) wobei $Q$
eine unitäre Matrix ($Q^*Q=I$) und $R$ eine verallgemeinerte obere Dreiecksmatrix sei, 
d.h. $r_{ij} = 0$ für $i > j$ heißt QR-Zerlegung von $A$.
\definition $Q \in \raxb{m}{m}$ heißt unitär, wenn $Q^*Q=QQ^*=I$\\
Es gilt: $Q^*Q=I \Leftrightarrow$ Die Spalten bzw. Zeilen von $Q$ sind orthonormal bzgl. $\inner{.}{.}_2$.\\
Eigenschaften unitärer Matrizen:
\begin{itemize}
  \item $\norm{Qx}_2^2 = (Qx)^*Qx = x^*\underbrace{Q^*Q}_{I}x = x^*x = \norm{x}_2^2 \Rightarrow$ Längenerhaltung, Drehungen
  \item Es lässt sich einfach zeigen: $\norm{QA}_2 = \norm{AQ}_2 = \norm{A}_2$
  \item $\kappa_2(Q) = \sqrt{\frac{\lambda_{max}(Q^*Q)}{\lambda_{min}(Q^*Q)}} = 1$
\end{itemize}
\satz Sei $A \in \rmxn$ Dann existiert eine QR-Zerlegung der Form 
\begin{align*}
  A=QR=\begin{pmatrix} Q_1 & Q_2 \end{pmatrix} \begin{pmatrix} R_1 \\ 0 \end{pmatrix} = Q_1 R_1
\end{align*}
\beweis Siehe Lehrbuch Numerik\\
Eigenschaften und Einsatz der QR-Zerlegung:
\begin{itemize}
  \item Sei $A \in \rnxn$ regulär. Durch die QR-Zerlegung wird die Kondition von $Ax=b$ nicht verschlechtert, denn:
    \begin{itemize}
      \item Man löst: $Rx = Q^*b \quad (Ax = b \Leftrightarrow QRx = b \Leftrightarrow Rx = Q^*b)$
      \item Man kann zeigen $\kappa_2(A) = \kappa_2(QR) = \kappa_2(R)$
    \end{itemize}
  \item QR-Zerlegung ist numerisch stabiler als LR-Zerlegung \begin{align*}
      \frac{\norm{\hat{x} - x}}{\norm{x}} \leq c\,eps\,\kappa_\infty(A)n^2 + \LandauO(eps^2)
    \end{align*}
  \item QR-Zerlegung ist doppelt so teuer wie LR-Zerlegung
  \item Einsatz: Ausgleichsrechnung
\end{itemize}
Methoden zur QR-Zerlegung:
\begin{itemize}
  \item Householder-Verfahren
  \item Given-Verfahren
  \item Gram-Schmidt-Verfahren
\end{itemize}
\matlab{qr(A)}

